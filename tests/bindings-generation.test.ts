import { describe, it, expect, beforeAll } from "vitest";
import { readFileSync } from "fs";
import path from "path";
import { fileURLToPath } from "url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));

// Import the WASM module directly
import init, { WitBindgen } from "../wit-bindgen-wasm/pkg/wit_bindgen_wasm.js";

const TEST_WIT = `package example:test;

world test-world {
    export greet: func(name: string) -> string;
}
`;

describe("Bindings Generation for All Languages", () => {
    let witBindgen: WitBindgen;

    beforeAll(async () => {
        // Initialize WASM module using the built file
        const wasmPath = path.join(__dirname, "../wit-bindgen-wasm/pkg/wit_bindgen_wasm_bg.wasm");
        const wasmBuffer = readFileSync(wasmPath);
        await init(wasmBuffer);

        // Create WitBindgen instance
        witBindgen = new WitBindgen();
    });

    const supportedLanguages = [
        { lang: "rust", extension: ".rs", expectedContent: "fn greet", minLength: 100 },
        { lang: "c", extension: ".h", expectedContent: "uint8_t", minLength: 100 },
        { lang: "cpp", extension: ".h", expectedContent: "namespace", minLength: 100 },
        { lang: "go", extension: ".go", expectedContent: "package", minLength: 100 },
        { lang: "csharp", extension: ".cs", expectedContent: "namespace", minLength: 100 },
        { lang: "moonbit", extension: ".mbt", expectedContent: "Generated by", minLength: 30 },
        { lang: "markdown", extension: ".md", expectedContent: "World test-world", minLength: 100 },
    ];

    supportedLanguages.forEach(({ lang, extension, expectedContent, minLength }) => {
        it(`should generate actual code stubs for ${lang}`, () => {
            const resultJson = witBindgen.generateBindings(TEST_WIT, lang, undefined);
            const result = JSON.parse(resultJson);

            // Verify files were generated
            expect(Object.keys(result).length).toBeGreaterThan(0);

            // Verify at least one file has the expected extension
            const hasExpectedFile = Object.keys(result).some((filename) => filename.endsWith(extension));
            expect(hasExpectedFile).toBe(true);

            // Find the main file with the expected extension
            const mainFile = Object.entries(result).find(([filename]) => filename.endsWith(extension));
            expect(mainFile).toBeDefined();

            if (mainFile) {
                const [filename, content] = mainFile as [string, string];

                // Convert from latin1 encoding
                const buffer = Buffer.from(content, "latin1");
                const text = buffer.toString("utf8");

                // Verify the file contains actual code, not just error messages
                expect(text.length).toBeGreaterThan(minLength);

                // Should not contain deprecation/unsupported messages
                expect(text).not.toContain("no longer supported");
                expect(text).not.toContain("deprecated");
                expect(text).not.toContain("has been removed");
                expect(text).not.toContain("migrate to");

                // Should contain expected language-specific content
                expect(text).toContain(expectedContent);

                console.log(`✅ ${lang}: Generated ${filename} (${text.length} bytes)`);
            }
        });

        it(`should not generate only README files for ${lang}`, () => {
            const resultJson = witBindgen.generateBindings(TEST_WIT, lang, undefined);
            const result = JSON.parse(resultJson);

            // Verify that not all files are README files
            const allFilenames = Object.keys(result);
            const onlyReadmes = allFilenames.every(
                (f) => f.toLowerCase().includes("readme") || f.toLowerCase().includes("read-me")
            );

            expect(onlyReadmes).toBe(false);

            // Verify at least one non-README code file exists
            const hasCodeFile = allFilenames.some(
                (f) => !f.toLowerCase().includes("readme") && (f.endsWith(extension) || f.includes("."))
            );

            expect(hasCodeFile).toBe(true);
        });
    });

    it("should generate different output for each language", () => {
        const results: Record<string, Record<string, string>> = {};

        for (const { lang } of supportedLanguages) {
            const resultJson = witBindgen.generateBindings(TEST_WIT, lang, undefined);
            results[lang] = JSON.parse(resultJson);
        }

        // Compare each pair to ensure they're different
        const languages = supportedLanguages.map((l) => l.lang);
        for (let i = 0; i < languages.length; i++) {
            for (let j = i + 1; j < languages.length; j++) {
                const lang1 = languages[i];
                const lang2 = languages[j];

                // Get file lists
                const files1 = Object.keys(results[lang1]);
                const files2 = Object.keys(results[lang2]);

                // Languages should generate different sets of files
                const sameFiles = JSON.stringify(files1.sort()) === JSON.stringify(files2.sort());

                if (!sameFiles) {
                    // Different file lists is good
                    expect(sameFiles).toBe(false);
                } else {
                    // If same file lists, content should be different
                    const firstFile1 = files1[0];
                    const content1 = results[lang1][firstFile1];
                    const content2 = results[lang2][firstFile1];

                    expect(content1).not.toEqual(content2);
                }
            }
        }
    });

    it("should handle complex WIT definitions for all languages", () => {
        const complexWit = `package example:complex;

interface logger {
    enum level {
        debug,
        info,
        warn,
        error,
    }

    record entry {
        level: level,
        message: string,
    }

    log: func(entry: entry);
}

world app {
    import logger;
    export run: func() -> result<_, string>;
}
`;

        for (const { lang, extension } of supportedLanguages) {
            const resultJson = witBindgen.generateBindings(complexWit, lang, undefined);
            const result = JSON.parse(resultJson);

            expect(Object.keys(result).length).toBeGreaterThan(0);

            const hasExpectedFile = Object.keys(result).some((filename) => filename.endsWith(extension));
            expect(hasExpectedFile).toBe(true);

            console.log(`✅ ${lang}: Successfully handled complex WIT (${Object.keys(result).length} files)`);
        }
    });
});
